snippet     header
abbr        include+main
options     head
    #include <bits/stdc++.h>
    #define all(v) v.begin(), v.end()
    typedef long long int lint;
    using namespace std;

    int main() {
        ${0}
    }

snippet     vector
abbr        vector<>
options     word
    vector<${1}>

snippet     queue
abbr        queue<>
options     word
    queue<${1}>

snippet     deque
abbr        deque<>
options     word
    deque<${1}>

snippet     priority_queue
abbr        priority_queue<>
options     word
    priority_queue<${1}>

snippet     unordered_map
abbr        unordered_map<>
options     word
    unordered_map<${1},${2}>

snippet     pair
abbr        declare pair
options     word
    pair<${1},${2}>

snippet     make_pair
abbr        make_pair(,)
options     word
    make_pair(${1},${2})

snippet     upper_bound
abbr        xより真に値が大きいもので最小のイテレータ
options     word
    upper_bound(${1}, ${2})

snippet     lower_bound
abbr        値がx以上の最小のイテレータ
options     word
    lower_bound(${1}, ${2})

snippet     ll 
abbr        long long int
options     word
    long long int

snippet     bits
abbr        include <bits/stdc++.h>
options     head
    #include <bits/stdc++.h>

snippet     powint
abbr        calc a^n
options     head
    // a^nを計算　O(log n)
    long long int powint(long long int a, long long int n) {
        if (n == 0) {
            return 1;
        } else {
            long long int temp = powint(a, n / 2);
            if (n % 2 == 0) {
                return temp * temp;
            } else {
                return temp * temp * a;
            }
        }
    }${0}

snippet     bit
abbr        n th number of a when representing p
options     head
    // aをp進数で表した時の下からn桁目を計算
    long long int bit(long long int a, long long int p, long long int n) {
        return (a / powint(p, n)) % p;
    }${0}

snippet     gcd
abbr        gcd by euclid
options     head
    //最大公約数の計算(ユークリッドの互除法)
    long long int gcd(long long int a, long long int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }${0}

snippet     combination
abbr        calc nCr by pascal's triangle
options     head
    //コンビネーション(パスカルの三角形)
    vector<vector<long long int>> comb(long long int n) {
        vector<vector<long long int>> res(n + 1, vector<long long int>(n + 1, 1));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                res[i][j] = res[i - 1][j - 1] + res[i - 1][j];
            }
        }
        return res;
    }${0}

snippet     pf_vec
abbr        prime factorization with vector
alias       prime factorization
options     head
    // 素因数分解 O(√N)
    vector<long long int> pf_vec(long long int n) {
        vector<long long int> res;
        for (long long int i = 2; i * i <= n; i++)
            if (n % i == 0) {
                res.push_back(i);
                while (n % i == 0) n /= i;
            }
        if (n != 1) res.push_back(n);
        return res;
    }${0}

snippet     pf_um
abbr        prime factorization with unordered_map
alias       prime factorization
options     head
    //素因数分解unordered_map版　O(√n)
    template <typename T>
    unordered_map<T, T> pf_um(T n) {
        unordered_map<T, T> res;
        for (long long int i = 2; i * i <= n; i++)
            while (n % i == 0) {
                res[i]++;
                n /= i;
            }
        if (n != 1) res[n]++;
        return res;
    }

snippet     inv_p
abbr        inverse element in Z_p
options     head
    // a^n mod pを計算　O(log n)
    long long int pow_p(long long int a, long long int n, long long int p) {
        if (n == 0) {
            return 1;
        } else {
            long long int temp = pow_p(a, n / 2, p);
            if (n % 2 == 0) {
                return (temp * temp) % p;
            } else {
                return (((temp * temp) % p) * a) % p;
            }
        }
    }

    // Z_pでのaの逆元を計算 O(log p)
    long long int inv_p(long long int a, long long int p) {
        return pow_p(a, p - 2, p);
    }${0}

snippet     cumulative_sum
abbr        cumulative_sum
options     head
    //累積和
    struct cumulative_sum {
        // data[i]:[0,i)の和
        vector<long long int> data;
        //コンストラクタ O(n)
        template <typename T>
        cumulative_sum(vector<T>& v) {
            data.assign(v.size() + 1, 0);
            for (int i = 0; i < (int)v.size(); i++) {
                data[i + 1] = data[i] + v[i];
            }
        }
        //[a,b)の和を求める
        long long int sum(long long int a, long long int b) {
            return data[b] - data[a];
        }
    };${0}

snippet     cumulative_sum_2D
abbr        cumulative sum 2D
options     head
    //二次元累積和
    struct cumulative_sum_2d {
        vector<vector<long long int>> data;
        //コンストラクタ
        template <typename T>
        cumulative_sum_2d(vector<vector<T>> &v) {
            data = vector<vector<long long int>>(
                v.size() + 1, vector<long long int>(v[0].size() + 1, 0));
            for (int i = 0; i < (int)v.size(); i++) {
                for (int j = 0; j < (int)v[0].size(); j++) {
                    data[i + 1][j + 1] =
                        data[i + 1][j] + data[i][j + 1] - data[i][j] + v[i][j];
                }
            }
        }
        //[a,b)×[c,d)の和を計算
        long long int sum(int a, int b, int c, int d) {
            return data[b][d] - data[b][c] - data[a][d] + data[a][c];
        }
    };${0}

snippet     bipartite
abbr        bipartite decomposition
options     head
    //連結二部グラフの分割を+1,-1で与える
    // graphは隣接リスト
    //bipartite[0]で二部グラフか判定([0]==1:二部グラフ、[0]==0:二部グラフでない)
    vector<int> bipartite(vector<vector<int>> &graph) {
        vector<int> res(graph.size(), 0);
        res[0] = 1;
        queue<int> bfs;
        bfs.push(0);
        while (bfs.size() > 0) {
            int depart = bfs.front();
            vector<int> dests = graph[depart];
            for (int i = 0; i < (int)dests.size(); i++) {
                if (res[dests[i]] == 0) {
                    res[dests[i]] = -res[depart];
                    bfs.push(dests[i]);
                } else if (res[dests[i]] * res[depart] == 1) {
                    res[0] = 0;
                    return res;
                }
            }
            bfs.pop();
        }
        return res;
    }${0}

snippet     isBipartite
abbr        judge the graph is bipartite or not
options     head
    //連結グラフが二部グラフか判定
    // graphは隣接リスト
    bool isBipartite(vector<vector<int>> &graph) {
        vector<int> res(graph.size(), 0);
        res[0] = 1;
        queue<int> bfs;
        bfs.push(0);
        while (bfs.size() > 0) {
            int depart = bfs.front();
            vector<int> dests = graph[depart];
            for (int i = 0; i < (int)dests.size(); i++) {
                if (res[dests[i]] == 0) {
                    res[dests[i]] = -res[depart];
                    bfs.push(dests[i]);
                } else if (res[dests[i]] * res[depart] == 1) {
                    return false;
                }
            }
            bfs.pop();
        }
        return true;
    }${0}

snippet     circle
abbr        identified v[0]~v[n]
options     head
    //円形リスト
    template <typename Num>
    struct circle {
        vector<Num> c;
        long long int _l;
        circle(long long int l) : _l(l) {
            c = vector<Num>(l);
        }
        Num& operator[](int k) {
            int temp = k % _l;
            if (temp < 0) temp += _l;
            return c[temp];
        }
    };${0}

snippet     union_find
abbr        struct union_find(long long int n)
alias       uf
options     head
    //素集合データ構造
    // ref:https://ei1333.github.io/luzhiled/snippets/structure/union-find.html
    struct union_find {
        // parent[v]==w(>=0):vの親はw
        // parent[v]==k(<0):vは根&&vの属するグループの要素数は-k
        vector<long long int> parent;
        //コンストラクタ
        union_find(long long int n) {
            parent.assign(n, -1);
        }
        // vの根を求める
        //求めると同時に親を根に置き換える(木の圧縮)
        long long int root(long long int v) {
            if (parent[v] < 0) {
                return v;
            } else {
                parent[v] = root(parent[v]);
                return parent[v];
            }
        }
        // vが属するグループの要素数を求める
        long long int size(long long int v) {
            return -parent[root(v)];
        }
        // vとwを繋げる
        void unite(long long int v, long long int w) {
            v = root(v);
            w = root(w);
            if (v == w) return;
            if (parent[v] < parent[w]) swap(v, w);
            parent[w] += parent[v];
            parent[v] = w;
        }
        // vとwが同値か判定
        bool isSame(long long int v, long long int w) {
            return root(v) == root(w);
        }
    };${0}

snippet     segment_tree
abbr        segment_tree<Mnd>
options     head
    //セグメント木
    // ref:https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html
    template <typename Mnd>
    struct segment_tree {
        int n;
        vector<Mnd> data;
        function<Mnd(Mnd, Mnd)> op;
        Mnd e;
        //サイズだけ指定して初期化
        segment_tree(int sz, function<Mnd(Mnd, Mnd)> f, Mnd a) : op(f), e(a) {
            n = 1;
            while (n < sz) n *= 2;
            data.assign(n * 2, e);
        }
        // vectorで要素を指定して初期化
        segment_tree(vector<Mnd> v, function<Mnd(Mnd, Mnd)> f, Mnd a)
            : op(f), e(a) {
            n = 1;
            while (n < (int)v.size()) n *= 2;
            data.assign(n * 2, e);
            for (int i = 0; i < (int)v.size(); i++) {
                *this[i] = v[i];
            }
        }
        //参照渡しなので代入とかもできる
        Mnd& operator[](const int& k) {
            return data[k + n];
        }
        //木を構築 O(n)
        void build() {
            for (int i = n - 1; i > 0; i--) {
                data[i] = op(data[2 * i], data[2 * i + 1]);
            }
        }
        //更新しつつ木を再構築 O(log n)
        void update(int k, Mnd x) {
            *this[k] = x;
            k = (k + n) / 2;
            while (k > 0) {
                data[k] = f(data[2 * k], data[2 * k + 1]);
            }
        }
        //[a,b)でのクエリに答える　O(log n)
        Mnd query(int a, int b) const {
            Mnd l = e, r = e;
            for (a += n, b += n; a < b; a /= 2, b /= 2) {
                if (a % 2 == 1) l = op(l, data[a++]);
                if (b % 2 == 1) r = op(r, data[--b]);
            }
            return op(l, r);
        }
    };${0}
